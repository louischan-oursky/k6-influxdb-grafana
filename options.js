import http from "k6/http";
import { sleep } from "k6";

const ramping_startTime = "30s";
const ramping_stage0_duration = "30s";
const ramping_stage1_duration = "3m30s";
const ramping_state2_duration = "30s";

const duration = "5m";

export const options = {
  scenarios: {
    my_web_test: {
      // some arbitrary scenario name
      executor: "constant-vus",
      vus: 50,
      duration,
      gracefulStop: "0s", // do not wait for iterations to finish in the end
      tags: { test_type: "website" }, // extra tags for the metrics generated by this scenario
      exec: "webtest", // the function this scenario will execute
    },
    my_api_test_1: {
      executor: "constant-arrival-rate",
      rate: 90,
      timeUnit: "1m", // 90 iterations per minute, i.e. 1.5 RPS
      duration,
      preAllocatedVUs: 10, // the size of the VU (i.e. worker) pool for this scenario
      tags: { test_type: "api" }, // different extra metric tags for this scenario
      env: { MY_CROC_ID: "1" }, // and we can specify extra environment variables as well!
      exec: "apitest", // this scenario is executing different code than the one above!
    },
    my_api_test_2: {
      executor: "ramping-arrival-rate",
      startTime: ramping_startTime, // the ramping API test starts a little later
      startRate: 50,
      timeUnit: "1s", // we start at 50 iterations per second
      stages: [
        { target: 200, duration: ramping_stage0_duration }, // go from 50 to 200 iters/s in the first 30 seconds
        { target: 200, duration: ramping_stage1_duration }, // hold at 200 iters/s for 3.5 minutes
        { target: 0, duration: ramping_state2_duration }, // ramp down back to 0 iters/s over the last 30 second
      ],
      preAllocatedVUs: 50, // how large the initial pool of VUs would be
      maxVUs: 100, // if the preAllocatedVUs are not enough, we can initialize more
      tags: { test_type: "api" }, // different extra metric tags for this scenario
      env: { MY_CROC_ID: "2" }, // same function, different environment variables
      exec: "apitest", // same function as the scenario above, but with different env vars
    },
    my_error_test: {
      // some arbitrary scenario name
      executor: "constant-vus",
      vus: 20,
      duration,
      gracefulStop: "0s", // do not wait for iterations to finish in the end
      tags: { test_type: "error_test" }, // extra tags for the metrics generated by this scenario
      exec: "error_test", // the function this scenario will execute
    },
  },
  discardResponseBodies: true,
  thresholds: {
    // we can set different thresholds for the different scenarios because
    // of the extra metric tags we set!
    "http_req_duration{test_type:api}": ["p(95)<250", "p(99)<350"],
    "http_req_duration{test_type:website}": ["p(99)<500"],
    // we can reference the scenario names as well
    "http_req_duration{scenario:my_api_test_2}": ["p(99)<300"],
  },
};

export function webtest() {
  http.get("https://test.k6.io/contacts.php");
  sleep(Math.random() * 2);
}

export function apitest() {
  http.get(
    `https://quickpizza.grafana.com/api/json?crocId=${__ENV.MY_CROC_ID}`,
  );
  // no need for sleep() here, the iteration pacing will be controlled by the
  // arrival-rate executors above!
}

export function error_test() {
  const good = "200";
  const bad = "500";
  const answer = Math.random();
  const url = `https://quickpizza.grafana.com/api/status/${answer < 0.05 ? bad : good}`;
  http.get(url);
}
